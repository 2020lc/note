# React面向组件定义
**函数式组件**
> 适用于简单组件（无state)  

```js
  // 创建函数式组件
  function MyComponent() {
    console.log(this); // undefined 因为babel编译后开启了严格模式
    return <h2>函数定义的组件，适用于简单组件的定义</h2>
  }
  // 渲染组件到页面
  ReactDom.render(<MyComponent />, document.getElementById('root'));

  /*
  * 1. React解析组件标签，找到MyComponent组件
  * 2. 发现组件是使用函数定义的，随后调用该函数，将返回的虚拟Dom转换为真是Dom,随后呈现在页面中
  */

```

+ 函数式组件使用props
```js
  function Person(props) {
    const {name, sex, age} = props;
    return (
      <ul>
        <li>姓名：{ name }</li>
        <li>性别：{ sex }</li>
        <li>年龄：{ age }</li>
      </ul>
    )
  }
  ReactDom.render(<Person name='jerry' sex='女' age={18} />, document.getElementById('test'));
```


**类式组件**
> 适用于复杂组件(有state)  

```js
  // 创建类式组件
  class MyComponent extends React.Component {
    render() { 
      // render是放在哪的？-- 类的原型对象上，供实例使用
      // render中的this是？ -- MyComponent的实例对象，MyComponent组件对象
      return <h2>类定义的组件，适用于复杂组件的定义</h2>
    }
  }
  // 渲染组件到页面
  ReactDom.render(<MyComponent />, document.getElementById('test'))

    /*
    * 1. React解析组件标签，找到MyComponent组件
    * 2. React发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用原型上的render方法
    * 3. 将render返回的虚拟Dom转为真实Dom, 随后呈现在页面中
    */
```

**组件实例的三大核心属性**

1. state
   ```js
    // 创建组件
    class Weather extends React.Component {
      // 构造器调用几次？ -- 1次
      constructor(props) {
        super(props);
        // 初始化状态
        this.state = {isHot: false, wind: '微风};
        this.changeWeather = this.changeWeather.bind(this);
      }
      // render调用几次？ -- 1 + n 次，1是初始化，n是状态更新次数
      render() {
        const {isHot, wind} = this.state;
        return <h2 onClick={this.changeWeather}>今天天气很{isHot ? '炎热': '凉快'}, {wind}</h2>
      }
      changeWeather() {
        // changeWeather放哪里？-- Weather的原型对象上，供实例使用
        // 类中的方法默认开了严格模式，所以changeWeather中的this为undefined
        const isHot = this.state.isHot;
        // 注意：状态必须通过setState进行更新，且更新是一种合并，不是替换
        this.setState({isHot: !isHot});
      }
    }
    ReactDom.render(<Weather />, document.getElementById('test'));
   ``` 
   + state的简写方式
     ```js
      class Weather extends React.Component {
        // 初始化状态
        state = {isHot: false, wind: '微风}
        render() {
          const {isHot, wind} = this.state;
          return <h2 onClick={this.changeWeather}>今天天气很{isHot ? '炎热': '凉快'}, {wind}</h2>
        }
        // 自定义方法
        changeWeather = () => {
          const isHot = this.state.isHot;
          this.setState({isHot: !isHot});
        }
      }
     ``` 
2. props
  > 只读属性  
  > constructor中需要给super传递props, 否则this.props为undefined
  ```js
    class Person extends React.Component {
        // 需要引入prop-types, 用于对组件标签属性进行限制, 引入全局多一个PropTypes
       // props接收规则
      static propTypes = {
        name: PropTypes.string.isRequired, // 字符串并且必传
        sex: PropTypes.string
        age: PropTypes.number,
        speak: PropTypes.func   // 为函数
      }
      // 指定默认值
      static defaultProps = {
        sex: '男',
        age: 18
      }
      render() {
        const {name, age, sex} = this.props;
        return (
          <ul>
            <li>姓名：{ name }</li>
            <li>性别：{ sex }</li>
            <li>年龄：{ age }</li>
          </ul>
        )
      }
    }
    <!-- ReactDom.render(<Person name='tom' age='18' sex='女' >, document.getElementById('test')); -->
    const p = {name: 'tom', age: '18', sex: '女'}
    ReactDom.render(<Person {...p} >, document.getElementById('test'));
  ```
3. refs

+ 字符串形式
```js
  class Demo extends React.Component {
    showName = () => {
      const { name } = this.$refs;
      alert(name.value);
    }
    showAge = () => {
      const { age } = this.$refs;
      alert(age.value);
    }
    render() {
      return (
        <div>
          <input ref='name' placeholder='请输入' />
          <button onClick={this.showName}>点击</button>
          <input ref='age' onBlur={ this.showAge } placeholder='请输入年龄' />
        </div>
      )
    }
  }
```

+ 回调函数形式
+ createRef

## 相关概念

**类**

```js
  // 创建一个Person类
  class Person {
    // 构造器方法
    constructor(name, age) {
      // 构造器中的this是谁？ -- 类的实例对象
      this.name = name;
      this.age = age;
    }
    // 一般方法
    speak() {
      // speak方法放在了哪里？-- 类的原型对象上，供实例使用
      // 通过Person实例调用speak时，speak中的this就是Person实例
      console.log(`我叫${this.name}，我的年龄是${this.age}`);
    }
  }
  // 创建一个Student类，继承于Person类
  class Student extends Person {
    constructor(name,age,grade) {
      super(name,age);
      this.grade = grade;
    }
    speak() {
      // 重写父类继承过来的方法
      console.log(`我叫${this.name}，我的年龄是${this.age}，我读的是${this.grade}年级`);
    }
    study() {
      console.log('我很努力的学习');
    }
    // 类中可以直接写赋值语句，如下代码的含义是： 给Student的实例对象添加一个属性，a: 1
    a = 1
  }
  class Dog {
 
  }
  // 创建一个Person的实例对象
  const p1 = new Person('tom', 18);
  const p2 = new Person('jerry', 19);

  const s1 = new Student('小张', 15, '高一');

  const d1 = new Dog();

  console.log(p1);
  console.log(p2);

  console.log(s1);
  s1.speak();
  s1.study();

  console.log(d1);
```

1. 类中的构造器不是必须写的，要对实例进行一些初始化的操作，如添加指定的属性时才写。
2. 如果B类继承了A类，且B类中写了构造器，那么B类构造器中的super是必须调用的。
3. 类中所定义的方法，是放在类的实例上，供实例使用。

**state状态**

| --   | --   | --   | --   |
| ---- | :--- | :--- | ---- |
| 人   | 状态 | 影响 | 行为 |
| 组件 | 状态 | 驱动 | 页面 |


**非受控组件**
```
<form>
<form>
```

**受控组件**

```js
  class  Login extends React.Component {
    state = {
      username: '',
      password: ''
    }

    saveUsername = () => {
      this.setState({username: e.target.value});
    }

    savePassword = () => {
      this.setState({password: e.target.value });
    }

    handleSubmit = (e) => {
      e.preventDefault();
      const { username, password } = this.state;
      // const { username, password } = this;
      // alert(`你输入的用户名是：${username.value},你输入的密码是${password.value}`)
    }

    render() {
      return (
        <form onSubmit={this.handleSubmit}>
          用户名：<input onChange={this.saveUsername} type="text" name="username" />
          密码：<input onChange={this.savePassword} type="password" name="password" />
          <button>登录</button>
        </form>
      )
    }
  }
```